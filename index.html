const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const timerFill = document.getElementById('timer-fill');
const saldoDisplay = document.getElementById('saldo-display');
const lucroPrevisto = document.getElementById('lucro-previsto');
const customInput = document.getElementById('custom-bet');

canvas.width = window.innerWidth * 0.94;
canvas.height = canvas.width * 0.8;

let saldo = 1000.00;
let valorAposta = 10;
const multiplicador = 2.0;

let power = 0, charging = false, angle = 0, dragStart = { x: 0, y: 0 };
let timeLeft = 3.00, timerAtivo = false, aguardandoParar = false; // timerAtivo começa false
let apostaDebitada = false;

let branca = { x: canvas.width * 0.85, y: canvas.height * 0.8, vx: 0, vy: 0, r: 8, color: '#fff' };
let dourada = { x: canvas.width / 2, y: canvas.height / 2, vx: 0, vy: 0, r: 8, color: '#ffd700' };
const cacapa = { x: 30, y: 30, r: 16 };

function selectBet(val, btn) {
    if(timerAtivo || aguardandoParar) return; // Bloqueia troca durante a jogada
    valorAposta = val;
    resetSelection();
    btn.classList.add('active-bet');
    customInput.value = "";
    atualizarLucro();
}

function selectCustom() {
    if(timerAtivo || aguardandoParar) return;
    resetSelection();
    customInput.classList.add('active-bet');
    updateCustomValue(customInput.value);
}

function resetSelection() {
    document.querySelectorAll('.bet-btn').forEach(b => b.classList.remove('active-bet'));
    customInput.classList.remove('active-bet');
}

function updateCustomValue(val) {
    valorAposta = parseFloat(val) || 0;
    atualizarLucro();
}

function atualizarLucro() {
    lucroPrevisto.innerText = `R$ ${(valorAposta * multiplicador).toFixed(2)}`;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(cacapa.x, cacapa.y, cacapa.r, 0, Math.PI*2); ctx.fill();

    if(charging) {
        ctx.beginPath();
        ctx.moveTo(branca.x, branca.y);
        ctx.lineTo(branca.x + Math.cos(angle) * (power * 1.2), branca.y + Math.sin(angle) * (power * 1.2));
        ctx.strokeStyle = "rgba(255,255,255,0.2)";
        ctx.stroke();
    }

    [branca, dourada].forEach(b => {
        ctx.fillStyle = b.color;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
    });

    update();
    requestAnimationFrame(draw);
}

function update() {
    // O cronômetro só corre se timerAtivo for true (ativado no toque)
    if(timerAtivo && !aguardandoParar) {
        timeLeft -= 1/60;
        document.getElementById('timer-text').innerText = Math.max(0, timeLeft).toFixed(2);
        timerFill.style.width = (timeLeft / 3 * 100) + "%";
        if(timeLeft <= 0) { 
            timerAtivo = false; 
            finalizarRodada(false, "TEMPO ESGOTADO!"); 
        }
    }

    [branca, dourada].forEach(b => {
        b.x += b.vx; b.y += b.vy;
        b.vx *= 0.985; b.vy *= 0.985;
        if(Math.hypot(b.vx, b.vy) < 0.15) { b.vx = 0; b.vy = 0; }
        if(b.x - b.r < 0 || b.x + b.r > canvas.width) b.vx *= -0.8;
        if(b.y - b.r < 0 || b.y + b.r > canvas.height) b.vy *= -0.8;
    });

    let dx = dourada.x - branca.x;
    let dy = dourada.y - branca.y;
    let dist = Math.hypot(dx, dy);
    if(dist < branca.r + dourada.r) {
        let collisionAngle = Math.atan2(dy, dx);
        let speedBranca = Math.hypot(branca.vx, branca.vy);
        dourada.vx = Math.cos(collisionAngle) * speedBranca * 0.9;
        dourada.vy = Math.sin(collisionAngle) * speedBranca * 0.9;
        branca.vx *= -0.3; branca.vy *= -0.3;
    }

    if(Math.hypot(dourada.x - cacapa.x, dourada.y - cacapa.y) < cacapa.r) {
        if(Math.hypot(dourada.vx, dourada.vy) > 0.1) finalizarRodada(true);
    }

    if(aguardandoParar && branca.vx === 0 && dourada.vx === 0) {
        finalizarRodada(false);
    }
}

function finalizarRodada(acertou, msg) {
    if(!aguardandoParar && !acertou && !msg) return;
    aguardandoParar = false; 
    timerAtivo = false; // Para o cronômetro

    if(acertou) {
        let win = valorAposta * multiplicador;
        saldo += win;
        showMsg(`GANHOU R$ ${win.toFixed(2)}!`, "gold");
    } else {
        showMsg(msg || "ERROU!", "#ff4444");
    }
    saldoDisplay.innerText = `R$ ${saldo.toFixed(2)}`;
    setTimeout(reset, 1500);
}

function showMsg(t, c) {
    const m = document.getElementById('msg-status');
    m.innerText = t; m.style.color = c; m.style.display = 'block';
    setTimeout(() => m.style.display = 'none', 1500);
}

function reset() {
    branca.vx = 0; branca.vy = 0;
    branca.x = canvas.width * 0.85; branca.y = canvas.height * 0.8;
    dourada.vx = 0; dourada.vy = 0;
    dourada.x = canvas.width / 2; dourada.y = canvas.height / 2;
    timeLeft = 3.00; 
    timerAtivo = false; // Resetado para falso para a próxima rodada
    aguardandoParar = false;
    apostaDebitada = false;
    document.getElementById('timer-text').innerText = "03.00";
    timerFill.style.width = "100%";
}

canvas.addEventListener('touchstart', (e) => {
    // Só inicia se a bola estiver parada e tiver saldo
    if(branca.vx === 0 && saldo >= valorAposta && valorAposta > 0 && !aguardandoParar) {
        charging = true;
        timerAtivo = true; // ATIVA O CRONÔMETRO NO TOQUE
        
        if(!apostaDebitada) {
            saldo -= valorAposta;
            saldoDisplay.innerText = `R$ ${saldo.toFixed(2)}`;
            apostaDebitada = true;
        }
        
        dragStart = { x: e.touches.clientX, y: e.touches.clientY };
    } else if (valorAposta <= 0) {
        showMsg("ESCOLHA UMA BET!", "white");
    }
});

canvas.addEventListener('touchmove', (e) => {
    if(!charging) return;
    let dx = dragStart.x - e.touches.clientX;
    let dy = dragStart.y - e.touches.clientY;
    angle = Math.atan2(dy, dx);
    power = Math.min(Math.hypot(dx, dy) / 2, 80);
});

canvas.addEventListener('touchend', () => {
    if(!charging) return;
    charging = false;
    if(power > 5) {
        branca.vx = Math.cos(angle) * (power / 5);
        branca.vy = Math.sin(angle) * (power / 5);
        aguardandoParar = true;
    }
});

draw();
